===================================
===== scale =======================
===================================

В Phaser есть специальный объект scale, 
который имеет несколько полезных методов и свойств. 

scaleMode имеет несколько опций, которые определяют, как <canvas> будет масштабироваться:

NO_SCALE — ничего не масштабировать.
EXACT_FIT — масштабировать с полным заполнением пустого места вертикально и горизонтально, не соблюдая соотношение (aspect ratio).
SHOW_ALL — масштабирует игру, но сохраняет соотношение так, что картинки не будут искажаться, как и при предыдущем значении. Возможно наличие чёрных полос по краям экрана, но мы можем жить с этим.
RESIZE — создаёт <canvas> с доступными шириной и высотой так, что вы можете помещать объекты в игру динамически; это расширенный режим (advanced mode).
USER_SCALE — позволяет вам делать динамическое масштабирование, подсчёт размеров, масштаб и соотношение самостоятельно; опять же это расширенный режим.



===================================
===== Загрузка спрайта мяча =======
===================================

game.load.image('ball', 'img/ball.png');
                   ↑
Первым параметром, которому мы хотим присвоить имя картинки, 
является имя, которое будет использоваться в нашем игровом коде 
- например, в нашем имени переменной ball - поэтому мы должны убедиться, что оно совпадает. 

Второй параметр - это относительный путь к самой картинке, мы загружаем спрайт для нашего мяча. (Заметьте, что имя файла не обязано совпадать с именем переменной, которой оно присваивается, однако так проще).


===================================
===== UPDATE ======================
===================================

// код внутри update - это requestAnimations - он всё время запущен



===================================
===================================
===================================
===== ДОБАВЛЕНИЕ ФИЗИКИ ===========
===================================
===================================
===================================

В Phaser есть три разных физических движка: 
Arcade Physics, 
P2,
Ninja Physics. 
Также есть четвёртый Box2D как платный плагин.

Для простых игры мы будем использовать Arcade Physics, 
потому что нам не нужны сложные геометрические вычисления.

инит физики
game.physics.startSystem(Phaser.Physics.ARCADE);

добавить мяч в физическую систему, потому что объект, отвечающий за физику в Phaser, не включён по умолчанию.
game.physics.enable(ball, Phaser.Physics.ARCADE);


===== ГРАВИТАЦИЯ ==================
ball.body.gravity.x = -25


===== Отскакивание от границ представления ==================
Самый простой способ заставить мячик от стен это сообщить фреймворку что мы хотим рассматривать границы элемента <canvas> как стены и не позволять мячу проходить через них
В Phaser это может быть просто реализовано с помощью свойства collideWorldsBound
ball.body.collideWorldBounds = true;


===== Позиционирование ==================
точка, из которой начинается позиционирование объекта (якорь), 
находится в левом верхнем углу самого этого объекта
 Но мы можем это изменить и переместить якорь в середину платформы по ширине и в самый низ по высоте, чтобы проще было позиционировать платформу, относительно нижней грани экрана. Добавьте следующую строку кода:

Мы можем использовать world.width и world.height для позиционирования платформы в том месте, 
где мы хотим: game.world.width*0.5 расположит платформу прямо по середине экрана. 


===== КОЛЛИЗИЯ ==================

game.physics.arcade.collide(ball, paddle);
                       ↑
 Для того, чтобы включить проверку коллизий между платформой и мячиком, вызовите функцию collide() в функции update()

immovable -   свойство для того, чтобы платформа не двигалась, когда мячик бьётся об неё. 

Чтобы добавить возможность проигрыша, давай те отключим определение коллизии с нижней гранью экрана
game.physics.arcade.checkCollision.down = false; 


ball.checkWorldBounds = true;
                           ↓↑
Если установлено значение true,
игровой объект проверяет, находится ли он в пределах границ мира в каждом кадре.
If it was previously out of bounds but is now intersecting the world bounds again it dispatches the onEnterBounds event.
Когда checkWorldBounds включен, он заставляет игровой объект вычислять свои полные границы каждый кадр.
Это очень дорогая операция! Будьте осторожны, если объектов много!


===================================
===== Управление ==================
===================================
Следующая проблема заключается в том, что мы не можем двигать платформу. 
Чтобы сделать это мы можем воспользоваться вводом input 
(мышь или сенсорный экран, в зависимости от платформы) 

paddle.x = game.input.x;
↓
Теперь, каждый кадр координата x платформы будет соответствовать координате x курсора. 
Однако, при старте игры, положение нашей платформы не по центру экрана, 
из-за того, что положение курсора не определено. 
Чтобы это исправить, добавим платформе координату x по умолчанию, 
на случай, если положение курсора не определено.
↑
paddle.x = game.input.x || game.world.width*0.5;

===================================
===== ТЕХТ ========================
===================================

var scoreText;
scoreText = game.add.text(5, 5, 'Points: 0', { 
  font: '18px Arial', ↑
  fill: '#0095DD'     ↑
});                   ↑
                      ↑
Функция text() может принимать четыре параметра:
  Координаты x и y текста.
  Сам текст.
  Шрифт 
  Стиль текста.



===================================
===== СОБЫТИЯ =====================
===================================

Скорее всего вы заметили вызов методов add() и addOnce() в двух блоках кода выше и хотите знать, чем они отличаются. 
Разница в том, что метод add() и привязанная к нему функция выполняется каждый раз, когда выполняется событие
метод addOnce() полезен, когда вы хотите, чтобы связанная с ним функция выполнилась единожды и не повторялась снова. 
В нашем случае при каждом событии outOfBounds будет выполняться ballLeaveScreen, 
но когда мяч покидает экран, сообщение с экрана удалится единожды.


===================================
===== Animations ==================
===================================
В Phaser анимация предполагает получение таблицы спрайтов из внешнего источника и последовательное отображение спрайтов. Например, мы заставим мяч раскачиваться, когда он что-то ударяется

ball = game.add.sprite(50, 250, 'ball');
ball.animations.add('wobble', [0,1,0,2,0,1,0,2,0], 24);

Для добавления анимации к объекту мы используем animations.add()метод, который содержит следующие параметры:

- Название, которое мы выбрали для анимации
- Массив, определяющий порядок отображения кадров во время анимации. 
Если вы еще раз посмотрите на wobble.pngизображение, вы увидите, что есть три кадра. 
Phaser извлекает их и сохраняет ссылки на них в массиве - позиции 0, 1 и 2. 
В приведенном выше массиве говорится, что мы отображаем кадр 0, затем 1, затем 0 и т. Д.
- Частота кадров в кадрах в секунду. 
Поскольку мы запускаем анимацию со скоростью 24 кадра в секунду, а количество кадров составляет 9, анимация будет отображаться чуть менее трех раз в секунду.





===================================
===== Tweens ======================
===================================
В то время как анимация воспроизводит внешние спрайты последовательно,
tweens анимация плавно анимирует свойства объекта в игровом мире, такие как ширина или непрозрачность.

[1]
var killTween = game.add.tween(brick.scale);

[2]
killTween.to({ x: 0, y: 0 }, 200, Phaser.Easing.Linear.None);

[3]
killTween.onComplete.addOnce(function(){
    brick.kill();
}, this);

[4]
killTween.start();


[1]
При определении новой анимации движения вы должны указать, какое свойство будет анимировано 
- в нашем случае вместо того, чтобы мгновенно скрывать кирпичи при ударе мячом, мы установим масштаб их ширины и высоты на ноль, чтобы они красиво исчезли. 
В конце мы используем add.tween()метод, указав brick.scaleв качестве аргумента, поскольку это то, что мы хотим анимировать.

[2]
to()Метод определяет состояние объекта в конце анимации. 
Это объект, содержащий желаемые конечные значения выбранного параметра 
(масштаб принимает значение масштаба, 1 - это 100% размера, 0 - 0% размера и т. Д.), 
Время анимации движения в миллисекундах и тип замедления для использования. для подростка.

[3]
добавим дополнительный onComplete обработчик событий, 
который определяет функцию, которая будет выполняться после завершения анимации движения.

[4]
Последнее, что нужно сделать, - это сразу запустить анимацию, используя start().

Выше - расширенная версия определения анимации движения, но мы также можем использовать сокращенный синтаксис:
game.add.tween(brick.scale).to({x:2,y:2}, 500, Phaser.Easing.Elastic.Out, true, 100)





===================================
===== Добавление кнопки ===========
===================================
var playing = false;
var startButton;

// Загрузка таблицы спрайтов кнопок

game.load.spritesheet('button', 'img/button.png', 120, 40);

// Добавление кнопки в игру
startButton = game.add.button(
  game.world.width * 0.5, // pos x
  game.world.height * 0.5,// pos y
  'button',  // имя
  startGame, // Ф-ция обратного вызова, которая будет выполняться при нажатии кнопки.
  this,      // Ссылка на this определение контекста выполнения
  1, 0, 2    // кадры анимации
);
startButton.anchor.set(0.5);

Примечание 
Событие  аналогично наведению указателя мыши, когда указатель выходит за пределы кнопки, 
а вниз - при нажатии кнопки

Когда кнопка нажата, мы удаляем ее, устанавливаем начальную скорость шара 
и устанавливаем playing переменную равной true.